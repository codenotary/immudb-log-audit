// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	ApiKeyAuthScopes  = "ApiKeyAuth.Scopes"
	PassetoAuthScopes = "PassetoAuth.Scopes"
)

// Defines values for CreateCollectionErrReplyLicenseType.
const (
	Free     CreateCollectionErrReplyLicenseType = "Free"
	Hardware CreateCollectionErrReplyLicenseType = "Hardware"
	Virtual  CreateCollectionErrReplyLicenseType = "Virtual"
)

// Defines values for FieldType.
const (
	BOOLEAN FieldType = "BOOLEAN"
	DOUBLE  FieldType = "DOUBLE"
	INTEGER FieldType = "INTEGER"
	STRING  FieldType = "STRING"
)

// Defines values for Operator.
const (
	EQ   Operator = "EQ"
	GE   Operator = "GE"
	GT   Operator = "GT"
	LE   Operator = "LE"
	LIKE Operator = "LIKE"
	LT   Operator = "LT"
	NE   Operator = "NE"
)

// Collection defines model for Collection.
type Collection struct {
	Fields      []Field `json:"fields"`
	IdFieldName string  `json:"idFieldName"`
	Indexes     []Index `json:"indexes"`
	Name        string  `json:"name"`
}

// CollectionCreateRequest defines model for CollectionCreateRequest.
type CollectionCreateRequest struct {
	Fields      *[]Field `json:"fields,omitempty"`
	IdFieldName *string  `json:"idFieldName,omitempty"`
	Indexes     *[]Index `json:"indexes,omitempty"`
}

// CollectionListResponse defines model for CollectionListResponse.
type CollectionListResponse struct {
	Collections []Collection `json:"collections"`
}

// CollectionUpdateRequest defines model for CollectionUpdateRequest.
type CollectionUpdateRequest struct {
	IdFieldName string `json:"idFieldName"`
}

// CreateCollectionErrReply defines model for CreateCollectionErrReply.
type CreateCollectionErrReply struct {
	// Code application-specific error code
	Code int `json:"code"`

	// Error application-level error message, for debugging
	Error string `json:"error"`

	// LicenseType the type of the license of the tenant
	LicenseType CreateCollectionErrReplyLicenseType `json:"license_type"`

	// MaxNumberOfCollections the maximum number of collections a tenant can create with the current license
	MaxNumberOfCollections int `json:"max_number_of_collections"`

	// Status user-level status message
	Status string `json:"status"`
}

// CreateCollectionErrReplyLicenseType the type of the license of the tenant
type CreateCollectionErrReplyLicenseType string

// Document defines model for Document.
type Document = map[string]interface{}

// DocumentAtRevision defines model for DocumentAtRevision.
type DocumentAtRevision struct {
	Document      Document `json:"document"`
	Revision      string   `json:"revision"`
	TransactionId string   `json:"transactionId"`
}

// DocumentAuditRequest defines model for DocumentAuditRequest.
type DocumentAuditRequest struct {
	Desc    bool `json:"desc"`
	Page    int  `json:"page"`
	PerPage int  `json:"perPage"`
}

// DocumentAuditResponse defines model for DocumentAuditResponse.
type DocumentAuditResponse struct {
	Revisions []DocumentAtRevision `json:"revisions"`
}

// DocumentInsertFromFileRequest defines model for DocumentInsertFromFileRequest.
type DocumentInsertFromFileRequest struct {
	Document DocumentInsertFromFileRequest_Document `json:"document"`
}

// DocumentInsertFromFileRequestDocument0 defines model for .
type DocumentInsertFromFileRequestDocument0 = string

// DocumentInsertFromFileRequestDocument1 defines model for .
type DocumentInsertFromFileRequestDocument1 = map[string]interface{}

// DocumentInsertFromFileRequest_Document defines model for DocumentInsertFromFileRequest.Document.
type DocumentInsertFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentInsertManyFromFileRequest defines model for DocumentInsertManyFromFileRequest.
type DocumentInsertManyFromFileRequest struct {
	Document DocumentInsertManyFromFileRequest_Document `json:"document"`
}

// DocumentInsertManyFromFileRequestDocument0 defines model for .
type DocumentInsertManyFromFileRequestDocument0 = string

// DocumentInsertManyFromFileRequestDocument1 defines model for .
type DocumentInsertManyFromFileRequestDocument1 = map[string]interface{}

// DocumentInsertManyFromFileRequest_Document defines model for DocumentInsertManyFromFileRequest.Document.
type DocumentInsertManyFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentInsertManyRequest defines model for DocumentInsertManyRequest.
type DocumentInsertManyRequest struct {
	Documents []map[string]interface{} `json:"documents"`
}

// DocumentInsertManyResponse defines model for DocumentInsertManyResponse.
type DocumentInsertManyResponse struct {
	DocumentIds   []string `json:"documentIds"`
	TransactionId *string  `json:"transactionId,omitempty"`
}

// DocumentInsertRequest defines model for DocumentInsertRequest.
type DocumentInsertRequest = interface{}

// DocumentInsertResponse defines model for DocumentInsertResponse.
type DocumentInsertResponse struct {
	DocumentId    string  `json:"documentId"`
	TransactionId *string `json:"transactionId,omitempty"`
}

// DocumentProofRequest defines model for DocumentProofRequest.
type DocumentProofRequest struct {
	ProofSinceTransactionId *int `json:"proofSinceTransactionId,omitempty"`
	TransactionId           int  `json:"transactionId"`
}

// DocumentProofResponse defines model for DocumentProofResponse.
type DocumentProofResponse struct {
	CollectionId    int64                `json:"collectionId"`
	Database        string               `json:"database"`
	EncodedDocument []byte               `json:"encodedDocument"`
	IdFieldName     string               `json:"idFieldName"`
	VerifiableTx    SchemaVerifiableTxV2 `json:"verifiableTx"`
}

// DocumentSearchRequest defines model for DocumentSearchRequest.
type DocumentSearchRequest struct {
	KeepOpen *bool   `json:"keepOpen,omitempty"`
	Page     int     `json:"page"`
	PerPage  int     `json:"perPage"`
	Query    *Query  `json:"query,omitempty"`
	SearchId *string `json:"searchId,omitempty"`
}

// DocumentSearchResponse defines model for DocumentSearchResponse.
type DocumentSearchResponse struct {
	Page      int                  `json:"page"`
	PerPage   int                  `json:"perPage"`
	Revisions []DocumentAtRevision `json:"revisions"`
	SearchId  string               `json:"searchId"`
}

// DocumentUpdateFromFileRequest defines model for DocumentUpdateFromFileRequest.
type DocumentUpdateFromFileRequest struct {
	Document *DocumentUpdateFromFileRequest_Document `json:"document,omitempty"`
	Query    *Query                                  `json:"query,omitempty"`
}

// DocumentUpdateFromFileRequestDocument0 defines model for .
type DocumentUpdateFromFileRequestDocument0 = string

// DocumentUpdateFromFileRequestDocument1 defines model for .
type DocumentUpdateFromFileRequestDocument1 = map[string]interface{}

// DocumentUpdateFromFileRequest_Document defines model for DocumentUpdateFromFileRequest.Document.
type DocumentUpdateFromFileRequest_Document struct {
	union json.RawMessage
}

// DocumentUpdateRequest defines model for DocumentUpdateRequest.
type DocumentUpdateRequest struct {
	Document map[string]interface{} `json:"document"`
	Query    Query                  `json:"query"`
}

// DocumentUpdateResponse defines model for DocumentUpdateResponse.
type DocumentUpdateResponse struct {
	DocumentId    string `json:"documentId"`
	Revision      string `json:"revision"`
	TransactionId string `json:"transactionId"`
}

// ErrReply defines model for ErrReply.
type ErrReply struct {
	// Code HTTP status code.
	Code int `json:"code"`

	// Error Application error message, for debugging.
	Error string `json:"error"`

	// Status HTTP status description.
	Status string `json:"status"`
}

// ExportID defines model for ExportID.
type ExportID struct {
	Id string `json:"id"`
}

// ExportInformation defines model for ExportInformation.
type ExportInformation struct {
	Date    time.Time `json:"date"`
	Id      string    `json:"id"`
	Message string    `json:"message"`
}

// ExportS3 defines model for ExportS3.
type ExportS3 struct {
	AccessKey string `json:"accessKey"`
	Bucket    string `json:"bucket"`
	Region    string `json:"region"`
	SecretKey string `json:"secretKey"`
	Token     string `json:"token"`
	UploadKey string `json:"uploadKey"`
}

// Field defines model for Field.
type Field struct {
	Name string     `json:"name"`
	Type *FieldType `json:"type,omitempty"`
}

// FieldComparison defines model for FieldComparison.
type FieldComparison struct {
	Field    string      `json:"field"`
	Operator Operator    `json:"operator"`
	Value    interface{} `json:"value"`
}

// FieldType defines model for FieldType.
type FieldType string

// Index defines model for Index.
type Index struct {
	Fields   []string `json:"fields"`
	IsUnique bool     `json:"isUnique"`
}

// IndexCreateRequest defines model for IndexCreateRequest.
type IndexCreateRequest struct {
	Fields   []string `json:"fields"`
	IsUnique bool     `json:"isUnique"`
}

// IndexCreateResponse defines model for IndexCreateResponse.
type IndexCreateResponse = map[string]interface{}

// IndexDeleteRequest defines model for IndexDeleteRequest.
type IndexDeleteRequest struct {
	Collection string   `json:"collection"`
	Fields     []string `json:"fields"`
}

// IndexDeleteResponse defines model for IndexDeleteResponse.
type IndexDeleteResponse = map[string]interface{}

// Operator defines model for Operator.
type Operator string

// OrderBy defines model for OrderBy.
type OrderBy struct {
	Desc  bool   `json:"desc"`
	Field string `json:"field"`
}

// PaginationRequest defines model for PaginationRequest.
type PaginationRequest struct {
	Page    int `json:"page"`
	PerPage int `json:"perPage"`
}

// PaginationResponse defines model for PaginationResponse.
type PaginationResponse struct {
	Page    int `json:"page"`
	PerPage int `json:"perPage"`
}

// Query defines model for Query.
type Query struct {
	Expressions *[]QueryExpression `json:"expressions,omitempty"`
	Limit       *int               `json:"limit,omitempty"`
	OrderBy     *[]OrderBy         `json:"orderBy,omitempty"`
}

// QueryExpression defines model for QueryExpression.
type QueryExpression struct {
	FieldComparisons *[]FieldComparison `json:"fieldComparisons,omitempty"`
}

// SchemaDualProofV2 DualProofV2 contains inclusion and consistency proofs
type SchemaDualProofV2 struct {
	// ConsistencyProof Consistency proof between Merkle Trees in the source and target transactions
	ConsistencyProof *[][]byte `json:"consistencyProof,omitempty"`

	// InclusionProof Inclusion proof of the source transaction hash in the main Merkle Tree
	InclusionProof *[][]byte `json:"inclusionProof,omitempty"`

	// SourceTxHeader Transaction header.
	SourceTxHeader *SchemaTxHeader `json:"sourceTxHeader,omitempty"`

	// TargetTxHeader Transaction header.
	TargetTxHeader *SchemaTxHeader `json:"targetTxHeader,omitempty"`
}

// SchemaEntry defines model for schemaEntry.
type SchemaEntry struct {
	// Expired If set to true, this entry has expired and the value is not retrieved
	Expired *bool `json:"expired,omitempty"`

	// Key Key of the target value (i.e. not the reference entry)
	Key          *[]byte           `json:"key,omitempty"`
	Metadata     *SchemaKVMetadata `json:"metadata,omitempty"`
	ReferencedBy *SchemaReference  `json:"referencedBy,omitempty"`

	// Revision Key's revision, in case of GetAt it will be 0
	Revision *string `json:"revision,omitempty"`

	// Tx Transaction id at which the target value was set (i.e. not the reference transaction id)
	Tx *string `json:"tx,omitempty"`

	// Value Value
	Value *[]byte `json:"value,omitempty"`
}

// SchemaExpiration defines model for schemaExpiration.
type SchemaExpiration struct {
	// ExpiresAt Entry expiration time (unix timestamp in seconds)
	ExpiresAt *string `json:"expiresAt,omitempty"`
}

// SchemaImmutableState defines model for schemaImmutableState.
type SchemaImmutableState struct {
	// Db The db name
	Db *string `json:"db,omitempty"`

	// PrecommittedTxHash State of the most recent precommitted transaction
	PrecommittedTxHash *[]byte `json:"precommittedTxHash,omitempty"`

	// PrecommittedTxId Id of the most recent precommitted transaction
	PrecommittedTxId *string `json:"precommittedTxId,omitempty"`

	// Signature Signature for the new state value
	Signature *SchemaSignature `json:"signature,omitempty"`

	// TxHash State of the most recent transaction
	TxHash *[]byte `json:"txHash,omitempty"`

	// TxId Id of the most recent transaction
	TxId *string `json:"txId,omitempty"`
}

// SchemaKVMetadata defines model for schemaKVMetadata.
type SchemaKVMetadata struct {
	// Deleted True if this entry denotes a logical deletion
	Deleted    *bool             `json:"deleted,omitempty"`
	Expiration *SchemaExpiration `json:"expiration,omitempty"`

	// NonIndexable If set to true, this entry will not be indexed and will only be accessed through GetAt calls
	NonIndexable *bool `json:"nonIndexable,omitempty"`
}

// SchemaReference defines model for schemaReference.
type SchemaReference struct {
	// AtTx At which transaction the key is bound, 0 if reference is not bound and should read the most recent reference
	AtTx *string `json:"atTx,omitempty"`

	// Key Reference key
	Key      *[]byte           `json:"key,omitempty"`
	Metadata *SchemaKVMetadata `json:"metadata,omitempty"`

	// Revision Revision of the reference entry
	Revision *string `json:"revision,omitempty"`

	// Tx Transaction if when the reference key was set
	Tx *string `json:"tx,omitempty"`
}

// SchemaSignature Signature for the new state value
type SchemaSignature struct {
	PublicKey *[]byte `json:"publicKey,omitempty"`
	Signature *[]byte `json:"signature,omitempty"`
}

// SchemaTx Transaction to verify
type SchemaTx struct {
	// Entries Raw entry values
	Entries *[]SchemaTxEntry `json:"entries,omitempty"`

	// Header Transaction header.
	Header *SchemaTxHeader `json:"header,omitempty"`

	// KvEntries KV entries in the transaction (parsed)
	KvEntries *[]SchemaEntry `json:"kvEntries,omitempty"`

	// ZEntries Sorted Set entries in the transaction (parsed)
	ZEntries *[]SchemaZEntry `json:"zEntries,omitempty"`
}

// SchemaTxEntry defines model for schemaTxEntry.
type SchemaTxEntry struct {
	// HValue Value hash
	HValue *[]byte `json:"hValue,omitempty"`

	// Key Raw key value (contains 1-byte prefix for kind of the key)
	Key      *[]byte           `json:"key,omitempty"`
	Metadata *SchemaKVMetadata `json:"metadata,omitempty"`

	// VLen Value length
	VLen *int32 `json:"vLen,omitempty"`

	// Value value, must be ignored when len(value) == 0 and vLen > 0.
	// Otherwise sha256(value) must be equal to hValue.
	Value *[]byte `json:"value,omitempty"`
}

// SchemaTxHeader Transaction header.
type SchemaTxHeader struct {
	// BlRoot Binary linking tree root (Root hash of the Merkle Tree)
	BlRoot *[]byte `json:"blRoot,omitempty"`

	// BlTxId Binary linking tree transaction ID
	// (ID of last transaction already in the main Merkle Tree)
	BlTxId *string `json:"blTxId,omitempty"`

	// EH Entries Hash - cumulative hash of all entries in the transaction
	EH *[]byte `json:"eH,omitempty"`

	// Id Transaction ID
	Id *string `json:"id,omitempty"`

	// Metadata TxMetadata contains metadata set to whole transaction
	Metadata *SchemaTxMetadata `json:"metadata,omitempty"`

	// Nentries Number of entries in a transaction
	Nentries *int32 `json:"nentries,omitempty"`

	// PrevAlh State value (Accumulative Hash - Alh) of the previous transaction
	PrevAlh *[]byte `json:"prevAlh,omitempty"`

	// Ts Unix timestamp of the transaction (in seconds)
	Ts *string `json:"ts,omitempty"`

	// Version Header version
	Version *int32 `json:"version,omitempty"`
}

// SchemaTxMetadata TxMetadata contains metadata set to whole transaction
type SchemaTxMetadata struct {
	// TruncatedTxID Entry expiration information
	TruncatedTxID *string `json:"truncatedTxID,omitempty"`
}

// SchemaVerifiableTxV2 defines model for schemaVerifiableTxV2.
type SchemaVerifiableTxV2 struct {
	// DualProof DualProofV2 contains inclusion and consistency proofs
	DualProof *SchemaDualProofV2 `json:"dualProof,omitempty"`

	// Signature Signature for the new state value
	Signature *SchemaSignature `json:"signature,omitempty"`

	// Tx Transaction to verify
	Tx *SchemaTx `json:"tx,omitempty"`
}

// SchemaZEntry defines model for schemaZEntry.
type SchemaZEntry struct {
	// AtTx At which transaction the key is bound,
	// 0 if reference is not bound and should read the most recent reference
	AtTx  *string      `json:"atTx,omitempty"`
	Entry *SchemaEntry `json:"entry,omitempty"`

	// Key Referenced key
	Key *[]byte `json:"key,omitempty"`

	// Score Sorted set element's score
	Score *float64 `json:"score,omitempty"`

	// Set Name of the sorted set
	Set *[]byte `json:"set,omitempty"`
}

// GetExportInformationParams defines parameters for GetExportInformation.
type GetExportInformationParams struct {
	// Id ID of export
	Id string `form:"id" json:"id"`
}

// CollectionUpdateJSONRequestBody defines body for CollectionUpdate for application/json ContentType.
type CollectionUpdateJSONRequestBody = CollectionUpdateRequest

// CollectionCreateJSONRequestBody defines body for CollectionCreate for application/json ContentType.
type CollectionCreateJSONRequestBody = CollectionCreateRequest

// UpdateDocumentJSONRequestBody defines body for UpdateDocument for application/json ContentType.
type UpdateDocumentJSONRequestBody = DocumentUpdateRequest

// UpdateDocumentMultipartRequestBody defines body for UpdateDocument for multipart/form-data ContentType.
type UpdateDocumentMultipartRequestBody = DocumentUpdateFromFileRequest

// DocumentCreateJSONRequestBody defines body for DocumentCreate for application/json ContentType.
type DocumentCreateJSONRequestBody = DocumentInsertRequest

// DocumentCreateMultipartRequestBody defines body for DocumentCreate for multipart/form-data ContentType.
type DocumentCreateMultipartRequestBody = DocumentInsertFromFileRequest

// AuditDocumentJSONRequestBody defines body for AuditDocument for application/json ContentType.
type AuditDocumentJSONRequestBody = DocumentAuditRequest

// GetDocumentProofJSONRequestBody defines body for GetDocumentProof for application/json ContentType.
type GetDocumentProofJSONRequestBody = DocumentProofRequest

// DocumentCreateManyJSONRequestBody defines body for DocumentCreateMany for application/json ContentType.
type DocumentCreateManyJSONRequestBody = DocumentInsertManyRequest

// DocumentCreateManyMultipartRequestBody defines body for DocumentCreateMany for multipart/form-data ContentType.
type DocumentCreateManyMultipartRequestBody = DocumentInsertManyFromFileRequest

// SearchDocumentJSONRequestBody defines body for SearchDocument for application/json ContentType.
type SearchDocumentJSONRequestBody = DocumentSearchRequest

// CreateIndexJSONRequestBody defines body for CreateIndex for application/json ContentType.
type CreateIndexJSONRequestBody = IndexCreateRequest

// DeleteIndexJSONRequestBody defines body for DeleteIndex for application/json ContentType.
type DeleteIndexJSONRequestBody = IndexDeleteRequest

// S3ExportJSONRequestBody defines body for S3Export for application/json ContentType.
type S3ExportJSONRequestBody = ExportS3

// AsDocumentInsertFromFileRequestDocument0 returns the union data inside the DocumentInsertFromFileRequest_Document as a DocumentInsertFromFileRequestDocument0
func (t DocumentInsertFromFileRequest_Document) AsDocumentInsertFromFileRequestDocument0() (DocumentInsertFromFileRequestDocument0, error) {
	var body DocumentInsertFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertFromFileRequestDocument0 overwrites any union data inside the DocumentInsertFromFileRequest_Document as the provided DocumentInsertFromFileRequestDocument0
func (t *DocumentInsertFromFileRequest_Document) FromDocumentInsertFromFileRequestDocument0(v DocumentInsertFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertFromFileRequestDocument0 performs a merge with any union data inside the DocumentInsertFromFileRequest_Document, using the provided DocumentInsertFromFileRequestDocument0
func (t *DocumentInsertFromFileRequest_Document) MergeDocumentInsertFromFileRequestDocument0(v DocumentInsertFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentInsertFromFileRequestDocument1 returns the union data inside the DocumentInsertFromFileRequest_Document as a DocumentInsertFromFileRequestDocument1
func (t DocumentInsertFromFileRequest_Document) AsDocumentInsertFromFileRequestDocument1() (DocumentInsertFromFileRequestDocument1, error) {
	var body DocumentInsertFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertFromFileRequestDocument1 overwrites any union data inside the DocumentInsertFromFileRequest_Document as the provided DocumentInsertFromFileRequestDocument1
func (t *DocumentInsertFromFileRequest_Document) FromDocumentInsertFromFileRequestDocument1(v DocumentInsertFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertFromFileRequestDocument1 performs a merge with any union data inside the DocumentInsertFromFileRequest_Document, using the provided DocumentInsertFromFileRequestDocument1
func (t *DocumentInsertFromFileRequest_Document) MergeDocumentInsertFromFileRequestDocument1(v DocumentInsertFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentInsertFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentInsertFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentInsertManyFromFileRequestDocument0 returns the union data inside the DocumentInsertManyFromFileRequest_Document as a DocumentInsertManyFromFileRequestDocument0
func (t DocumentInsertManyFromFileRequest_Document) AsDocumentInsertManyFromFileRequestDocument0() (DocumentInsertManyFromFileRequestDocument0, error) {
	var body DocumentInsertManyFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertManyFromFileRequestDocument0 overwrites any union data inside the DocumentInsertManyFromFileRequest_Document as the provided DocumentInsertManyFromFileRequestDocument0
func (t *DocumentInsertManyFromFileRequest_Document) FromDocumentInsertManyFromFileRequestDocument0(v DocumentInsertManyFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertManyFromFileRequestDocument0 performs a merge with any union data inside the DocumentInsertManyFromFileRequest_Document, using the provided DocumentInsertManyFromFileRequestDocument0
func (t *DocumentInsertManyFromFileRequest_Document) MergeDocumentInsertManyFromFileRequestDocument0(v DocumentInsertManyFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentInsertManyFromFileRequestDocument1 returns the union data inside the DocumentInsertManyFromFileRequest_Document as a DocumentInsertManyFromFileRequestDocument1
func (t DocumentInsertManyFromFileRequest_Document) AsDocumentInsertManyFromFileRequestDocument1() (DocumentInsertManyFromFileRequestDocument1, error) {
	var body DocumentInsertManyFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentInsertManyFromFileRequestDocument1 overwrites any union data inside the DocumentInsertManyFromFileRequest_Document as the provided DocumentInsertManyFromFileRequestDocument1
func (t *DocumentInsertManyFromFileRequest_Document) FromDocumentInsertManyFromFileRequestDocument1(v DocumentInsertManyFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentInsertManyFromFileRequestDocument1 performs a merge with any union data inside the DocumentInsertManyFromFileRequest_Document, using the provided DocumentInsertManyFromFileRequestDocument1
func (t *DocumentInsertManyFromFileRequest_Document) MergeDocumentInsertManyFromFileRequestDocument1(v DocumentInsertManyFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentInsertManyFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentInsertManyFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsDocumentUpdateFromFileRequestDocument0 returns the union data inside the DocumentUpdateFromFileRequest_Document as a DocumentUpdateFromFileRequestDocument0
func (t DocumentUpdateFromFileRequest_Document) AsDocumentUpdateFromFileRequestDocument0() (DocumentUpdateFromFileRequestDocument0, error) {
	var body DocumentUpdateFromFileRequestDocument0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentUpdateFromFileRequestDocument0 overwrites any union data inside the DocumentUpdateFromFileRequest_Document as the provided DocumentUpdateFromFileRequestDocument0
func (t *DocumentUpdateFromFileRequest_Document) FromDocumentUpdateFromFileRequestDocument0(v DocumentUpdateFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentUpdateFromFileRequestDocument0 performs a merge with any union data inside the DocumentUpdateFromFileRequest_Document, using the provided DocumentUpdateFromFileRequestDocument0
func (t *DocumentUpdateFromFileRequest_Document) MergeDocumentUpdateFromFileRequestDocument0(v DocumentUpdateFromFileRequestDocument0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsDocumentUpdateFromFileRequestDocument1 returns the union data inside the DocumentUpdateFromFileRequest_Document as a DocumentUpdateFromFileRequestDocument1
func (t DocumentUpdateFromFileRequest_Document) AsDocumentUpdateFromFileRequestDocument1() (DocumentUpdateFromFileRequestDocument1, error) {
	var body DocumentUpdateFromFileRequestDocument1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDocumentUpdateFromFileRequestDocument1 overwrites any union data inside the DocumentUpdateFromFileRequest_Document as the provided DocumentUpdateFromFileRequestDocument1
func (t *DocumentUpdateFromFileRequest_Document) FromDocumentUpdateFromFileRequestDocument1(v DocumentUpdateFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDocumentUpdateFromFileRequestDocument1 performs a merge with any union data inside the DocumentUpdateFromFileRequest_Document, using the provided DocumentUpdateFromFileRequestDocument1
func (t *DocumentUpdateFromFileRequest_Document) MergeDocumentUpdateFromFileRequestDocument1(v DocumentUpdateFromFileRequestDocument1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t DocumentUpdateFromFileRequest_Document) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DocumentUpdateFromFileRequest_Document) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CollectionDelete request
	CollectionDelete(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionGet request
	CollectionGet(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionUpdate request with any body
	CollectionUpdateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectionUpdate(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionCreate request with any body
	CollectionCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CollectionCreate(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDocument request with any body
	UpdateDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDocument(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DocumentCreate request with any body
	DocumentCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DocumentCreate(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditDocument request with any body
	AuditDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AuditDocument(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDocumentProof request with any body
	GetDocumentProofWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DocumentCreateMany request with any body
	DocumentCreateManyWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DocumentCreateMany(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchDocument request with any body
	SearchDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchDocument(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIndex request with any body
	CreateIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIndex(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIndex request with any body
	DeleteIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteIndex(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CollectionsList request
	CollectionsList(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// S3Export request with any body
	S3ExportWithBody(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	S3Export(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExportInformation request
	GetExportInformation(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCurrentState request
	GetCurrentState(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CollectionDelete(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionDeleteRequest(c.Server, ledger, collection)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionGet(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionGetRequest(c.Server, ledger, collection)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionUpdateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionUpdateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionUpdate(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionUpdateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionCreateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionCreate(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionCreateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDocumentRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDocument(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDocumentRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreate(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditDocumentWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditDocumentRequestWithBody(c.Server, ledger, collection, documentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditDocument(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditDocumentRequest(c.Server, ledger, collection, documentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDocumentProofWithBody(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocumentProofRequestWithBody(c.Server, ledger, collection, documentId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDocumentProof(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDocumentProofRequest(c.Server, ledger, collection, documentId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateManyWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateManyRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DocumentCreateMany(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDocumentCreateManyRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDocumentWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDocumentRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchDocument(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchDocumentRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIndex(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIndexRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndexWithBody(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequestWithBody(c.Server, ledger, collection, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIndex(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIndexRequest(c.Server, ledger, collection, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CollectionsList(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCollectionsListRequest(c.Server, ledger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3ExportWithBody(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ExportRequestWithBody(c.Server, ledger, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) S3Export(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewS3ExportRequest(c.Server, ledger, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExportInformation(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportInformationRequest(c.Server, ledger, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCurrentState(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCurrentStateRequest(c.Server, ledger)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCollectionDeleteRequest generates requests for CollectionDelete
func NewCollectionDeleteRequest(server string, ledger string, collection string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionGetRequest generates requests for CollectionGet
func NewCollectionGetRequest(server string, ledger string, collection string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCollectionUpdateRequest calls the generic CollectionUpdate builder with application/json body
func NewCollectionUpdateRequest(server string, ledger string, collection string, body CollectionUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectionUpdateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCollectionUpdateRequestWithBody generates requests for CollectionUpdate with any type of body
func NewCollectionUpdateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollectionCreateRequest calls the generic CollectionCreate builder with application/json body
func NewCollectionCreateRequest(server string, ledger string, collection string, body CollectionCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCollectionCreateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCollectionCreateRequestWithBody generates requests for CollectionCreate with any type of body
func NewCollectionCreateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateDocumentRequest calls the generic UpdateDocument builder with application/json body
func NewUpdateDocumentRequest(server string, ledger string, collection string, body UpdateDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDocumentRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewUpdateDocumentRequestWithBody generates requests for UpdateDocument with any type of body
func NewUpdateDocumentRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDocumentCreateRequest calls the generic DocumentCreate builder with application/json body
func NewDocumentCreateRequest(server string, ledger string, collection string, body DocumentCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDocumentCreateRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDocumentCreateRequestWithBody generates requests for DocumentCreate with any type of body
func NewDocumentCreateRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAuditDocumentRequest calls the generic AuditDocument builder with application/json body
func NewAuditDocumentRequest(server string, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuditDocumentRequestWithBody(server, ledger, collection, documentId, "application/json", bodyReader)
}

// NewAuditDocumentRequestWithBody generates requests for AuditDocument with any type of body
func NewAuditDocumentRequestWithBody(server string, ledger string, collection string, documentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "document-id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document/%s/audit", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDocumentProofRequest calls the generic GetDocumentProof builder with application/json body
func NewGetDocumentProofRequest(server string, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetDocumentProofRequestWithBody(server, ledger, collection, documentId, "application/json", bodyReader)
}

// NewGetDocumentProofRequestWithBody generates requests for GetDocumentProof with any type of body
func NewGetDocumentProofRequestWithBody(server string, ledger string, collection string, documentId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "document-id", runtime.ParamLocationPath, documentId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/document/%s/proof", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDocumentCreateManyRequest calls the generic DocumentCreateMany builder with application/json body
func NewDocumentCreateManyRequest(server string, ledger string, collection string, body DocumentCreateManyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDocumentCreateManyRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDocumentCreateManyRequestWithBody generates requests for DocumentCreateMany with any type of body
func NewDocumentCreateManyRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/documents", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSearchDocumentRequest calls the generic SearchDocument builder with application/json body
func NewSearchDocumentRequest(server string, ledger string, collection string, body SearchDocumentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchDocumentRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewSearchDocumentRequestWithBody generates requests for SearchDocument with any type of body
func NewSearchDocumentRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/documents/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateIndexRequest calls the generic CreateIndex builder with application/json body
func NewCreateIndexRequest(server string, ledger string, collection string, body CreateIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIndexRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewCreateIndexRequestWithBody generates requests for CreateIndex with any type of body
func NewCreateIndexRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIndexRequest calls the generic DeleteIndex builder with application/json body
func NewDeleteIndexRequest(server string, ledger string, collection string, body DeleteIndexJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteIndexRequestWithBody(server, ledger, collection, "application/json", bodyReader)
}

// NewDeleteIndexRequestWithBody generates requests for DeleteIndex with any type of body
func NewDeleteIndexRequestWithBody(server string, ledger string, collection string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collection", runtime.ParamLocationPath, collection)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collection/%s/indexes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCollectionsListRequest generates requests for CollectionsList
func NewCollectionsListRequest(server string, ledger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/collections", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewS3ExportRequest calls the generic S3Export builder with application/json body
func NewS3ExportRequest(server string, ledger string, body S3ExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewS3ExportRequestWithBody(server, ledger, "application/json", bodyReader)
}

// NewS3ExportRequestWithBody generates requests for S3Export with any type of body
func NewS3ExportRequestWithBody(server string, ledger string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/export/s3", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExportInformationRequest generates requests for GetExportInformation
func NewGetExportInformationRequest(server string, ledger string, params *GetExportInformationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/export/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCurrentStateRequest generates requests for GetCurrentState
func NewGetCurrentStateRequest(server string, ledger string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ledger", runtime.ParamLocationPath, ledger)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ledger/%s/state", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CollectionDelete request
	CollectionDeleteWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionDeleteResponse, error)

	// CollectionGet request
	CollectionGetWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionGetResponse, error)

	// CollectionUpdate request with any body
	CollectionUpdateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error)

	CollectionUpdateWithResponse(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error)

	// CollectionCreate request with any body
	CollectionCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error)

	CollectionCreateWithResponse(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error)

	// UpdateDocument request with any body
	UpdateDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error)

	UpdateDocumentWithResponse(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error)

	// DocumentCreate request with any body
	DocumentCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error)

	DocumentCreateWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error)

	// AuditDocument request with any body
	AuditDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error)

	AuditDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error)

	// GetDocumentProof request with any body
	GetDocumentProofWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error)

	GetDocumentProofWithResponse(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error)

	// DocumentCreateMany request with any body
	DocumentCreateManyWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error)

	DocumentCreateManyWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error)

	// SearchDocument request with any body
	SearchDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error)

	SearchDocumentWithResponse(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error)

	// CreateIndex request with any body
	CreateIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	CreateIndexWithResponse(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error)

	// DeleteIndex request with any body
	DeleteIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	DeleteIndexWithResponse(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error)

	// CollectionsList request
	CollectionsListWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*CollectionsListResponse, error)

	// S3Export request with any body
	S3ExportWithBodyWithResponse(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ExportResponse, error)

	S3ExportWithResponse(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ExportResponse, error)

	// GetExportInformation request
	GetExportInformationWithResponse(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*GetExportInformationResponse, error)

	// GetCurrentState request
	GetCurrentStateWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetCurrentStateResponse, error)
}

type CollectionDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ErrReply
	JSON402      *CreateCollectionErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentUpdateResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r UpdateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DocumentCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentInsertResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DocumentCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DocumentCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentAuditResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r AuditDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDocumentProofResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentProofResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetDocumentProofResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDocumentProofResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DocumentCreateManyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentInsertManyResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON413      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DocumentCreateManyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DocumentCreateManyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DocumentSearchResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r SearchDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexCreateResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CreateIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIndexResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IndexDeleteResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON404      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r DeleteIndexResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIndexResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CollectionsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionListResponse
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r CollectionsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CollectionsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type S3ExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportID
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON409      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r S3ExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r S3ExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportInformation
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetExportInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCurrentStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SchemaImmutableState
	JSON400      *ErrReply
	JSON403      *ErrReply
	JSON500      *ErrReply
}

// Status returns HTTPResponse.Status
func (r GetCurrentStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCurrentStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CollectionDeleteWithResponse request returning *CollectionDeleteResponse
func (c *ClientWithResponses) CollectionDeleteWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionDeleteResponse, error) {
	rsp, err := c.CollectionDelete(ctx, ledger, collection, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionDeleteResponse(rsp)
}

// CollectionGetWithResponse request returning *CollectionGetResponse
func (c *ClientWithResponses) CollectionGetWithResponse(ctx context.Context, ledger string, collection string, reqEditors ...RequestEditorFn) (*CollectionGetResponse, error) {
	rsp, err := c.CollectionGet(ctx, ledger, collection, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionGetResponse(rsp)
}

// CollectionUpdateWithBodyWithResponse request with arbitrary body returning *CollectionUpdateResponse
func (c *ClientWithResponses) CollectionUpdateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error) {
	rsp, err := c.CollectionUpdateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionUpdateResponse(rsp)
}

func (c *ClientWithResponses) CollectionUpdateWithResponse(ctx context.Context, ledger string, collection string, body CollectionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionUpdateResponse, error) {
	rsp, err := c.CollectionUpdate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionUpdateResponse(rsp)
}

// CollectionCreateWithBodyWithResponse request with arbitrary body returning *CollectionCreateResponse
func (c *ClientWithResponses) CollectionCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error) {
	rsp, err := c.CollectionCreateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionCreateResponse(rsp)
}

func (c *ClientWithResponses) CollectionCreateWithResponse(ctx context.Context, ledger string, collection string, body CollectionCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*CollectionCreateResponse, error) {
	rsp, err := c.CollectionCreate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionCreateResponse(rsp)
}

// UpdateDocumentWithBodyWithResponse request with arbitrary body returning *UpdateDocumentResponse
func (c *ClientWithResponses) UpdateDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error) {
	rsp, err := c.UpdateDocumentWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDocumentResponse(rsp)
}

func (c *ClientWithResponses) UpdateDocumentWithResponse(ctx context.Context, ledger string, collection string, body UpdateDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDocumentResponse, error) {
	rsp, err := c.UpdateDocument(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDocumentResponse(rsp)
}

// DocumentCreateWithBodyWithResponse request with arbitrary body returning *DocumentCreateResponse
func (c *ClientWithResponses) DocumentCreateWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error) {
	rsp, err := c.DocumentCreateWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateResponse(rsp)
}

func (c *ClientWithResponses) DocumentCreateWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateResponse, error) {
	rsp, err := c.DocumentCreate(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateResponse(rsp)
}

// AuditDocumentWithBodyWithResponse request with arbitrary body returning *AuditDocumentResponse
func (c *ClientWithResponses) AuditDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error) {
	rsp, err := c.AuditDocumentWithBody(ctx, ledger, collection, documentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditDocumentResponse(rsp)
}

func (c *ClientWithResponses) AuditDocumentWithResponse(ctx context.Context, ledger string, collection string, documentId string, body AuditDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditDocumentResponse, error) {
	rsp, err := c.AuditDocument(ctx, ledger, collection, documentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditDocumentResponse(rsp)
}

// GetDocumentProofWithBodyWithResponse request with arbitrary body returning *GetDocumentProofResponse
func (c *ClientWithResponses) GetDocumentProofWithBodyWithResponse(ctx context.Context, ledger string, collection string, documentId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error) {
	rsp, err := c.GetDocumentProofWithBody(ctx, ledger, collection, documentId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocumentProofResponse(rsp)
}

func (c *ClientWithResponses) GetDocumentProofWithResponse(ctx context.Context, ledger string, collection string, documentId string, body GetDocumentProofJSONRequestBody, reqEditors ...RequestEditorFn) (*GetDocumentProofResponse, error) {
	rsp, err := c.GetDocumentProof(ctx, ledger, collection, documentId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDocumentProofResponse(rsp)
}

// DocumentCreateManyWithBodyWithResponse request with arbitrary body returning *DocumentCreateManyResponse
func (c *ClientWithResponses) DocumentCreateManyWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error) {
	rsp, err := c.DocumentCreateManyWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateManyResponse(rsp)
}

func (c *ClientWithResponses) DocumentCreateManyWithResponse(ctx context.Context, ledger string, collection string, body DocumentCreateManyJSONRequestBody, reqEditors ...RequestEditorFn) (*DocumentCreateManyResponse, error) {
	rsp, err := c.DocumentCreateMany(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDocumentCreateManyResponse(rsp)
}

// SearchDocumentWithBodyWithResponse request with arbitrary body returning *SearchDocumentResponse
func (c *ClientWithResponses) SearchDocumentWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error) {
	rsp, err := c.SearchDocumentWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDocumentResponse(rsp)
}

func (c *ClientWithResponses) SearchDocumentWithResponse(ctx context.Context, ledger string, collection string, body SearchDocumentJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchDocumentResponse, error) {
	rsp, err := c.SearchDocument(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchDocumentResponse(rsp)
}

// CreateIndexWithBodyWithResponse request with arbitrary body returning *CreateIndexResponse
func (c *ClientWithResponses) CreateIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndexWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

func (c *ClientWithResponses) CreateIndexWithResponse(ctx context.Context, ledger string, collection string, body CreateIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIndexResponse, error) {
	rsp, err := c.CreateIndex(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIndexResponse(rsp)
}

// DeleteIndexWithBodyWithResponse request with arbitrary body returning *DeleteIndexResponse
func (c *ClientWithResponses) DeleteIndexWithBodyWithResponse(ctx context.Context, ledger string, collection string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndexWithBody(ctx, ledger, collection, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

func (c *ClientWithResponses) DeleteIndexWithResponse(ctx context.Context, ledger string, collection string, body DeleteIndexJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteIndexResponse, error) {
	rsp, err := c.DeleteIndex(ctx, ledger, collection, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIndexResponse(rsp)
}

// CollectionsListWithResponse request returning *CollectionsListResponse
func (c *ClientWithResponses) CollectionsListWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*CollectionsListResponse, error) {
	rsp, err := c.CollectionsList(ctx, ledger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCollectionsListResponse(rsp)
}

// S3ExportWithBodyWithResponse request with arbitrary body returning *S3ExportResponse
func (c *ClientWithResponses) S3ExportWithBodyWithResponse(ctx context.Context, ledger string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*S3ExportResponse, error) {
	rsp, err := c.S3ExportWithBody(ctx, ledger, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ExportResponse(rsp)
}

func (c *ClientWithResponses) S3ExportWithResponse(ctx context.Context, ledger string, body S3ExportJSONRequestBody, reqEditors ...RequestEditorFn) (*S3ExportResponse, error) {
	rsp, err := c.S3Export(ctx, ledger, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseS3ExportResponse(rsp)
}

// GetExportInformationWithResponse request returning *GetExportInformationResponse
func (c *ClientWithResponses) GetExportInformationWithResponse(ctx context.Context, ledger string, params *GetExportInformationParams, reqEditors ...RequestEditorFn) (*GetExportInformationResponse, error) {
	rsp, err := c.GetExportInformation(ctx, ledger, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportInformationResponse(rsp)
}

// GetCurrentStateWithResponse request returning *GetCurrentStateResponse
func (c *ClientWithResponses) GetCurrentStateWithResponse(ctx context.Context, ledger string, reqEditors ...RequestEditorFn) (*GetCurrentStateResponse, error) {
	rsp, err := c.GetCurrentState(ctx, ledger, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCurrentStateResponse(rsp)
}

// ParseCollectionDeleteResponse parses an HTTP response from a CollectionDeleteWithResponse call
func ParseCollectionDeleteResponse(rsp *http.Response) (*CollectionDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionGetResponse parses an HTTP response from a CollectionGetWithResponse call
func ParseCollectionGetResponse(rsp *http.Response) (*CollectionGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionUpdateResponse parses an HTTP response from a CollectionUpdateWithResponse call
func ParseCollectionUpdateResponse(rsp *http.Response) (*CollectionUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionCreateResponse parses an HTTP response from a CollectionCreateWithResponse call
func ParseCollectionCreateResponse(rsp *http.Response) (*CollectionCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 402:
		var dest CreateCollectionErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON402 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateDocumentResponse parses an HTTP response from a UpdateDocumentWithResponse call
func ParseUpdateDocumentResponse(rsp *http.Response) (*UpdateDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentUpdateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDocumentCreateResponse parses an HTTP response from a DocumentCreateWithResponse call
func ParseDocumentCreateResponse(rsp *http.Response) (*DocumentCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DocumentCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentInsertResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAuditDocumentResponse parses an HTTP response from a AuditDocumentWithResponse call
func ParseAuditDocumentResponse(rsp *http.Response) (*AuditDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuditDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentAuditResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDocumentProofResponse parses an HTTP response from a GetDocumentProofWithResponse call
func ParseGetDocumentProofResponse(rsp *http.Response) (*GetDocumentProofResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDocumentProofResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentProofResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDocumentCreateManyResponse parses an HTTP response from a DocumentCreateManyWithResponse call
func ParseDocumentCreateManyResponse(rsp *http.Response) (*DocumentCreateManyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DocumentCreateManyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentInsertManyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchDocumentResponse parses an HTTP response from a SearchDocumentWithResponse call
func ParseSearchDocumentResponse(rsp *http.Response) (*SearchDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DocumentSearchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIndexResponse parses an HTTP response from a CreateIndexWithResponse call
func ParseCreateIndexResponse(rsp *http.Response) (*CreateIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexCreateResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIndexResponse parses an HTTP response from a DeleteIndexWithResponse call
func ParseDeleteIndexResponse(rsp *http.Response) (*DeleteIndexResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIndexResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IndexDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCollectionsListResponse parses an HTTP response from a CollectionsListWithResponse call
func ParseCollectionsListResponse(rsp *http.Response) (*CollectionsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CollectionsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseS3ExportResponse parses an HTTP response from a S3ExportWithResponse call
func ParseS3ExportResponse(rsp *http.Response) (*S3ExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &S3ExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetExportInformationResponse parses an HTTP response from a GetExportInformationWithResponse call
func ParseGetExportInformationResponse(rsp *http.Response) (*GetExportInformationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportInformation
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCurrentStateResponse parses an HTTP response from a GetCurrentStateWithResponse call
func ParseGetCurrentStateResponse(rsp *http.Response) (*GetCurrentStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCurrentStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SchemaImmutableState
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrReply
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
